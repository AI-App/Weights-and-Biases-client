import getpass
import logging
import os
import shutil
import subprocess
import sys
import tempfile
from typing import Any, Dict, List, Optional, Sequence

from dockerpycreds.utils import find_executable  # type: ignore
import pkg_resources
from six.moves import shlex_quote
import wandb
from wandb import docker
from wandb.apis.internal import Api
from wandb.errors import DockerException, ExecutionException, LaunchException
from yaspin import yaspin  # type: ignore

from . import _project_spec
from .utils import _is_wandb_dev_uri, _is_wandb_local_uri
from ..lib.git import GitRepo

_logger = logging.getLogger(__name__)

_GENERATED_DOCKERFILE_NAME = "Dockerfile.wandb-autogenerated"


def validate_docker_installation() -> None:
    """
    Verify if Docker is installed on host machine.
    """
    if not find_executable("docker"):
        raise ExecutionException(
            "Could not find Docker executable. "
            "Ensure Docker is installed as per the instructions "
            "at https://docs.docker.com/install/overview/."
        )


def validate_docker_env(project: _project_spec.Project) -> None:
    """Ensure project has a docker image associated with it"""
    if not project.docker_image:
        raise ExecutionException(
            "Project with docker environment must specify the docker image "
            "to use via 'docker_image' field."
        )


def generate_docker_base_image(
    project: _project_spec.Project, entry_cmd: str
) -> Optional[str]:
    """
    Uses project and entry point to generate the docker image
    """
    path = project.project_dir

    # this check will always pass since the dir attribute will always be populated
    # by _fetch_project_local
    assert isinstance(path, str)
    cmd: Sequence[str] = [
        "jupyter-repo2docker",
        "--no-run",
        "--image-name={}".format(project.base_image),
        "--user-id={}".format(project.docker_user_id),
        path,
        '"{}"'.format(entry_cmd),
    ]

    _logger.info(
        "Generating docker base image from git repo or finding image if it already exists..."
    )
    build_log = os.path.join(project.project_dir, "build.log")
    with yaspin(
        text="Generating docker base image {}, this may take a few minutes.  Detailed logs: {}".format(
            project.base_image, build_log
        ),
    ).bouncingBar.blue as spinner:
        with open(build_log, "w") as f:
            process = subprocess.Popen(cmd, stdout=f, stderr=f)
            res = process.wait()
            if res == 0:
                spinner.ok("âœ… ")
            else:
                spinner.fail("ðŸ’¥ ")
                return None
    return project.base_image


def docker_image_exists(docker_image: str) -> bool:
    """Checks if a specific image is already available"""
    try:
        docker.run(["docker", "image", "inspect", docker_image])
        return True
    except DockerException:
        return False


def pull_docker_image(docker_image: str) -> None:
    """Pulls the requested docker image"""
    try:
        docker.run(["docker", "pull", docker_image])
    except DockerException as e:
        raise LaunchException("Docker server returned error: {}".format(e))


def build_docker_image_if_needed(
    project: _project_spec.Project, api: Api, copy_code: bool
) -> str:
    """
    Build a docker image containing the project in `work_dir`, using the base image.
    :param project: Project class instance
    :param api: instance of wandb.apis.internal Api
    :param copy_code: boolean indicating if code should be copied into the docker container
    """

    if _is_wandb_local_uri(api.settings("base_url")) and sys.platform == "darwin":
        _, _, port = _, _, port = api.settings("base_url").split(":")
        base_url = "http://host.docker.internal:{}".format(port)
    elif _is_wandb_dev_uri(api.settings("base_url")):
        base_url = "http://host.docker.internal:9002"
    else:
        base_url = api.settings("base_url")
    image_uri = _get_docker_image_uri(name=project.name, work_dir=project.project_dir)
    if docker_image_exists(image_uri):
        wandb.termlog("Using existing image: {}".format(image_uri))
        project.docker_image = image_uri
        return image_uri
    copy_code_line = ""
    workdir_line = ""
    workdir = "/root"
    if copy_code:
        # TODO: consider making the workdir /wandb
        workdir = os.path.join("/home/", getpass.getuser())
        copy_code_line = "COPY ./wandb-project-contents/ {}\n".format(workdir)
        workdir_line = "WORKDIR {}\n".format(workdir)
    wandb_project = project.target_project
    wandb_entity = project.target_entity
    requirements_line = ""
    if docker.is_buildx_installed():
        # TODO: introspect the docker container for the pip cache dir
        # TODO: introspect the docker container for the uid and gid permissions
        requirements_line = "RUN --mount=type=cache,target={}/.cache,uid=1000,gid=1000 ".format(
            workdir
        )
    else:
        wandb.termwarn(
            "Docker BuildX is not installed, for faster builds upgrade docker: https://github.com/docker/buildx#installing"
        )
        requirements_line = "RUN WANDB_DISABLE_CACHE=true "
    base_requirements = os.path.join(project.project_dir, "requirements.txt")
    # TODO: make this configurable?
    if os.path.exists(base_requirements):
        include_only = set()
        with open(base_requirements) as f:
            for pkg in pkg_resources.parse_requirements(f):
                # TODO: pkg_resources doesn't declare the name attribute?
                include_only.add(shlex_quote(pkg.name.lower()))  # type: ignore
        requirements_line += "WANDB_ONLY_INCLUDE={} ".format(",".join(include_only))

    requirements_line += "python _wandb_bootstrap.py\n"
    # TODO: I don't think we want the API_KEY in the docker build
    dockerfile = (
        "FROM {imagename}\n"
        "{copy_code_line}"
        "{workdir_line}"
        "{requirements_line}"
        "ENV WANDB_BASE_URL={base_url}\\\n"
        "WANDB_API_KEY={api_key}\\\n"
        "WANDB_PROJECT={wandb_project}\\\n"
        "WANDB_ENTITY={wandb_entity}\\\n"
        "WANDB_NAME={wandb_name}\\\n"
        "WANDB_LAUNCH=True\\\n"
        "WANDB_LAUNCH_CONFIG_PATH={config_path}\\\n"
        "WANDB_RUN_ID={run_id}\n"
    ).format(
        imagename=project.base_image,
        copy_code_line=copy_code_line,
        workdir_line=workdir_line,
        requirements_line=requirements_line,
        base_url=base_url,
        api_key=api.api_key,
        wandb_project=wandb_project,
        wandb_entity=wandb_entity,
        wandb_name=project.name,
        config_path=project.config_path,
        run_id=project.run_id or None,
    )
    build_ctx_path = _create_docker_build_ctx(project.project_dir, dockerfile)
    _logger.info("=== Building docker image %s ===", image_uri)
    shutil.copy(
        os.path.join(os.path.dirname(__file__), "templates", "_wandb_bootstrap.py"),
        os.path.join(build_ctx_path, "wandb-project-contents"),
    )

    dockerfile = os.path.join(build_ctx_path, _GENERATED_DOCKERFILE_NAME)
    wandb.termlog("Generating launch image {}".format(image_uri))
    try:
        image = docker.build(
            tags=[image_uri], file=dockerfile, context_path=build_ctx_path,
        )
    except DockerException as e:
        raise LaunchException("Error communicating with docker client: {}".format(e))

    try:
        os.remove(build_ctx_path)
    except Exception:
        _logger.info(
            "Temporary docker context file %s was not deleted.", build_ctx_path
        )
    # TODO: mypy isn't picking up types from wandb.docker
    return str(image)


def get_docker_command(image: str, docker_args: Dict[str, Any] = None) -> List[str]:
    """
    Constructs the docker command using the image and docker args.
    :param image: Docker image to be run
    :docker_args: dictionary of additional docker args for the command
    """
    docker_path = "docker"
    cmd: List[Any] = [docker_path, "run", "--rm"]

    if docker_args:
        for name, value in docker_args.items():
            # Passed just the name as boolean flag
            if isinstance(value, bool) and value:
                if len(name) == 1:
                    cmd += ["-" + name]
                else:
                    cmd += ["--" + name]
            else:
                # Passed name=value
                if len(name) == 1:
                    cmd += ["-" + name, value]
                else:
                    cmd += ["--" + name, value]

    cmd += [image]
    return [shlex_quote(c) for c in cmd]


def _get_docker_image_uri(name: str, work_dir: str) -> str:
    """
    Returns an appropriate Docker image URI for a project based on the git hash of the specified
    working directory.
    :param name: The URI of the Docker repository with which to tag the image. The
                           repository URI is used as the prefix of the image URI.
    :param work_dir: Path to the working directory in which to search for a git commit hash
    """
    name = name.replace(" ", "-") if name else "docker-project"
    # Optionally include first 7 digits of git SHA in tag name, if available.

    git_commit = GitRepo(work_dir).last_commit
    version_string = ":" + str(git_commit[:7]) if git_commit else ""
    return name + version_string


def _create_docker_build_ctx(work_dir: str, dockerfile_contents: str) -> str:
    """
    Creates build context temp dir containing Dockerfile and project code, returning path to temp dir
    """
    directory = tempfile.mkdtemp()
    dst_path = os.path.join(directory, "wandb-project-contents")
    shutil.copytree(src=work_dir, dst=dst_path)
    with open(os.path.join(directory, _GENERATED_DOCKERFILE_NAME), "w") as handle:
        handle.write(dockerfile_contents)
    return directory
